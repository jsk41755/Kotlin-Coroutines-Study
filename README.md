# Kotlin-Coroutines-Study

<details>
<summary> Coroutine Cancellation</summary>
<div markdown="1">

## Why Cancellation Seems Simple, But is hard

### 1. **취소의 기본 개념**

- 코루틴을 취소하면 실행 중인 작업이 중단됩니다. 특정 코루틴 스코프 내에서 모든 코루틴이 취소될 수 있으며, **부모 작업**이 취소되면 **자식 작업**도 함께 취소됩니다. 이는 비교적 직관적으로 이해할 수 있습니다.

### 2. **취소의 협력적 특성**

- 코루틴의 취소는 **자동으로 이루어지지 않고**, 중단 함수(suspending function)가 취소 여부를 확인하고 취소를 수락해야만 작동합니다. 즉, 취소가 발생해도 중단 함수 내에서 **취소 체크포인트**가 있어야 취소가 반영됩니다.
- 예를 들어, 이미지 압축 작업을 중단시키려면 각 중단 함수 호출 사이에 취소 여부를 확인하는 코드(예: `isActive` 또는 `ensureActive`)가 필요합니다. 이를 통해 코루틴이 취소되었는지 확인하고, 취소된 경우에는 더 이상 작업을 계속하지 않고 종료됩니다.

### 3. **취소 처리 시의 문제점**

- 코루틴 취소가 제대로 지원되지 않으면, 취소 요청을 받아도 코루틴이 계속 실행될 수 있습니다. 예를 들어, 파일을 읽거나 이미지를 압축하는 작업에서 취소 체크포인트가 없으면, 코루틴이 취소되었더라도 해당 작업이 끝날 때까지 계속됩니다.
- **취소 체크포인트**는 중단 함수 사이에 위치해야 하며, 이를 통해 취소 여부를 주기적으로 확인해야 합니다.

### 4. **실제 안드로이드 환경에서의 취소**

- 안드로이드 환경에서는 **생명 주기(Lifecycle)**에 따라 코루틴이 자동으로 취소될 수 있습니다. 예를 들어, **ViewModel 스코프**에서 실행 중인 코루틴은 사용자가 화면을 뒤로 이동하거나 액티비티가 종료되면 자동으로 취소됩니다. 이런 상황에서 취소를 제대로 지원하지 않으면, **메모리 누수**나 **성능 문제**, 심지어 **앱 크래시**가 발생할 수 있습니다.

## The Consequences of Cancellation

- **취소의 기본 구조**:
    - 코루틴 내에서 취소된 **작업(job)**은 더 이상 실행되지 않지만, 동일한 부모 작업 내의 **다른 형제 작업**은 계속 실행됩니다.
    - 반면, **부모 작업**이 취소되면 모든 자식 작업도 함께 취소됩니다. 이는 **구조적 동시성(Structured Concurrency)**의 원칙에 따른 것으로, 부모 작업의 취소는 하위 모든 작업에 영향을 미칩니다.
- **코루틴 스코프 취소**:
    - **코루틴 스코프**가 취소되면 해당 스코프 내에서 실행 중이던 모든 코루틴과 작업이 취소됩니다.
    - 한 번 취소된 코루틴 스코프는 더 이상 재사용할 수 없으며, 새로운 코루틴을 시작할 수 없습니다. 만약 스코프 자체는 유지하면서 자식 작업들만 취소하고 싶다면, `coroutineContext.cancelChildren()`을 사용할 수 있습니다.
- **취소의 내부 작동**:
    - 코루틴이 취소될 때, **취소 예외(CancellationException)**가 발생하며, 코루틴은 더 이상 실행되지 않습니다. 예를 들어, `ensureActive()` 함수는 코루틴이 여전히 활성 상태인지 확인하고, 취소된 경우 예외를 발생시킵니다.
    - 코루틴은 상태 머신처럼 동작하여, 실행 상태(Active)에서 **취소 중 상태(Cancelling)**로 전환되고, 마지막으로 **취소된 상태(Cancelled)**로 이동합니다. 이 과정에서 자원을 정리하는 등의 작업이 필요할 수 있습니다.
- **취소 예외의 특수성**:
    - **CancellationException**은 다른 예외와 달리 오류로 간주되지 않으며, 코루틴이 취소된 후에도 남은 작업을 처리할 수 있는 시간을 허용합니다. 예를 들어, 파일을 열고 있던 스트림을 닫는 등의 정리 작업을 할 수 있습니다.

## Cancellation Trap 1 Try-Catch

1. **취소 예외의 처리 문제**:
    - 코루틴에서 취소가 발생하면 `CancellationException`이 발생하고, 이는 코루틴의 모든 중단점(suspension point)에서 던져집니다.
    - 만약 `try-catch` 블록에서 모든 예외를 포괄적으로 처리하면, `CancellationException`도 함께 잡히게 됩니다. 이로 인해 코루틴이 취소되었음에도 불구하고 취소 상태를 부모 작업이 인식하지 못하게 되어, **무한 반복**이 발생할 수 있습니다.
2. **취소 예외를 삼키는 문제**:
    - 예를 들어, API 요청을 반복하는 코루틴에서 `try-catch`로 모든 예외를 처리한 경우, `CancellationException`이 발생하더라도 코루틴이 계속해서 실행될 수 있습니다. 이는 부모 작업이 취소된 상태를 알 수 없기 때문입니다.
    - 이로 인해, 무한 반복 또는 불필요한 리소스 낭비가 발생할 수 있습니다.
3. **해결 방법**:
    - **특정 예외만 처리**: 모든 예외를 처리하는 대신, 특정 예외(예: 네트워크 오류)만을 처리하여 `CancellationException`을 부모 작업으로 전달할 수 있습니다.
    - **취소 예외 재발생**: `catch` 블록에서 `CancellationException`을 확인하고, 취소된 경우에는 이 예외를 다시 던져서 부모 작업이 취소를 인식하도록 합니다.
    - **`ensureActive` 사용**: `ensureActive()`를 사용해 코루틴이 여전히 활성 상태인지 확인하고, 취소된 경우 `CancellationException`을 발생시킵니다.

## Cancellation Trap 2 Transaction like Behavior

### 문제)

코드에서 원격 API 호출로 주문을 생성하고, 그 주문의 추적 번호를 로컬 데이터베이스에 저장하는 과정이 있다. 여기서 발생할 수 있는 문제는 다음과 같다.

1. **원격 API 호출 성공 후 코루틴 취소**: 주문이 원격 API에 성공적으로 전달되었지만, 로컬 데이터베이스에 추적 번호를 저장하기 전에 코루틴이 취소될 수 있습니다. 이렇게 되면 원격 서버에는 주문 정보가 있지만, 클라이언트(앱)에는 추적 번호가 저장되지 않아 데이터 불일치가 발생합니다.
2. **트랜잭션과 유사한 동작**: 데이터베이스 트랜잭션처럼, 모든 작업이 성공적으로 완료되었을 때만 데이터베이스에 반영되도록 하는 것이 이상적입니다. 하지만 코루틴이 중간에 취소되면, 일부 작업이 완료되지 않아 일관성이 깨질 수 있습니다.

---

### 해결책)

- **withContext(NonCancellable)**: 특정 코드 블록을 **취소 불가능**하게 만들어, 그 코드가 반드시 실행되도록 보장합니다. 예를 들어, 주문이 성공적으로 생성된 후, 추적 번호를 저장하는 코드가 반드시 실행되도록 합니다. 하지만 이 방법은 위험할 수 있으며, 무한 루프나 대규모 작업이 취소되지 않고 계속 실행될 위험이 있습니다.
- **애플리케이션 전역의 코루틴 스코프 생성**: **글로벌 스코프(Global Scope)** 대신, 애플리케이션의 수명과 연동된 전역 코루틴 스코프를 생성하여 사용할 수 있습니다. 이렇게 하면 뷰모델 스코프나 생명 주기 스코프와는 독립적으로 동작하며, 특정 작업이 취소되지 않고 실행되도록 할 수 있습니다. 이를 통해 주문이 성공적으로 완료된 후 추적 번호를 저장하는 작업이 반드시 완료되도록 보장할 수 있습니다.
- **Supervisor Job**: 여러 코루틴이 동일한 스코프에서 실행될 때, 하나의 코루틴이 실패하더라도 다른 코루틴에 영향을 미치지 않도록 하기 위해 **Supervisor Job**을 사용합니다.

## Cancellation Trap 3 Try-Finally

### 문제 설명

코드에서는 파일에 데이터를 쓰고, 코루틴이 취소될 경우 **임시 파일을 삭제**하는 과정이 포함되어 있습니다. 주요 과정은 다음과 같습니다:

1. **파일에 기록**: 파일에 데이터베이스 레코드를 작성하는 함수가 있습니다. 이 함수는 5줄을 파일에 쓰는 작업을 시뮬레이션하며, 중간에 지연(delay)을 추가하여 코루틴이 취소될 가능성을 보여줍니다.
2. **취소 시 파일 삭제**: 코루틴이 취소되면, 파일이 완전히 기록되지 않기 때문에 **임시 파일을 삭제**해야 합니다. 이를 위해 `finally` 블록에서 파일 삭제 작업을 수행합니다.
3. **문제 발생**: 코루틴이 취소될 경우, `finally` 블록은 실행되지만, 코루틴이 이미 **취소 상태**일 때는 **서스펜드 함수(suspend function)**가 호출되지 않습니다. 예를 들어, 파일 삭제 작업이 서스펜드 함수 내에서 이루어지면, 코루틴이 취소된 상태에서는 이 작업이 건너뛰어져 파일이 삭제되지 않습니다.

---

### 해결책

- **`withContext(NonCancellable)`**: 서스펜드 함수를 사용하는 코드가 **취소되지 않도록** `finally` 블록 안에서 `withContext(NonCancellable)`를 사용해야 합니다. 이를 통해 코루틴이 취소된 상태에서도 `finally` 블록 내의 모든 코드가 정상적으로 실행됩니다.
    - 예를 들어, 파일을 삭제하는 함수가 서스펜드 함수라면, `withContext(NonCancellable)`로 감싸주면 코루틴이 취소된 상태에서도 해당 파일이 안전하게 삭제됩니다.

---

### 핵심 요약

코루틴이 취소될 경우, 서스펜드 함수는 더 이상 호출되지 않지만, `finally` 블록에서 리소스를 정리해야 할 경우 `withContext(NonCancellable)`를 사용하여 **취소 불가** 상태에서 반드시 리소스 정리 작업을 완료하도록 해야 합니다

## EnsureActive vs yield

### 1. **ensureActive**

- `ensureActive`는 **취소 여부를 확인**하는 함수로, 코루틴이 취소된 경우 `CancellationException`을 발생시킵니다.
- **중단 함수**가 아니므로, **스레드 전환**이 발생하지 않습니다. 단순히 코루틴이 취소되었는지 확인하고, 취소된 경우 부모 스코프에 이를 알리는 역할을 합니다.

### 2. **yield**

- `yield`는 **중단 함수**이므로, 실행 중인 코루틴이 중단되고, 다른 코루틴이 실행될 수 있는 기회를 줍니다.
- `yield` 역시 코루틴이 취소되었는지 확인하고, 취소된 경우 **취소 예외**를 던집니다.
- 주요 차이점은 **스레드 전환**이 가능하다는 점입니다. 코루틴이 `yield`를 만나면 중단 상태에 들어가고, 다른 코루틴이 실행될 수 있는 기회를 갖습니다.

### 차이점 요약:

- `ensureActive`는 코루틴의 취소를 확인하지만, 중단 상태로 들어가지 않기 때문에 스레드 전환이 일어나지 않습니다.
- `yield`는 중단 상태로 들어가서 다른 코루틴이 실행될 수 있는 기회를 주며, **동시성 프로그래밍**에서 더 효율적으로 동작할 수 있습니다.

결론적으로, `ensureActive`는 빠른 실행을 원할 때 사용하고, `yield`는 **다른 코루틴에게 실행 기회를 제공**하면서 **동시성 작업을 최적화**할 때 유용합니다

</div>
</details>
